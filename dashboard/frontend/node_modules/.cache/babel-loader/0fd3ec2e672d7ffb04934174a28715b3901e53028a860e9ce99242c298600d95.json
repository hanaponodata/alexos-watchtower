{"ast":null,"code":"import React,{createContext,useContext,useEffect,useRef,useState}from'react';import toast from'react-hot-toast';import{jsx as _jsx}from\"react/jsx-runtime\";const WebSocketContext=/*#__PURE__*/createContext();export function WebSocketProvider(_ref){let{children}=_ref;const[isConnected,setIsConnected]=useState(false);const[metrics,setMetrics]=useState(null);const[events,setEvents]=useState([]);const[agents,setAgents]=useState([]);const wsRef=useRef(null);const reconnectTimeoutRef=useRef(null);const connect=()=>{try{const protocol=window.location.protocol==='https:'?'wss:':'ws:';const wsUrl=\"\".concat(protocol,\"//\").concat(window.location.host,\"/dashboard/ws\");wsRef.current=new WebSocket(wsUrl);wsRef.current.onopen=()=>{setIsConnected(true);console.log('WebSocket connected');// Subscribe to dashboard updates\nwsRef.current.send(JSON.stringify({action:'subscribe',channels:['metrics','events','agents']}));};wsRef.current.onmessage=event=>{try{const data=JSON.parse(event.data);handleMessage(data);}catch(error){console.error('Error parsing WebSocket message:',error);}};wsRef.current.onclose=()=>{setIsConnected(false);console.log('WebSocket disconnected - this is expected if WebSocket endpoint is not available');// Don't attempt to reconnect if the endpoint doesn't exist\n// reconnectTimeoutRef.current = setTimeout(() => {\n//   connect();\n// }, 5000);\n};wsRef.current.onerror=error=>{console.log('WebSocket connection failed - this is expected if WebSocket endpoint is not available');// Don't show error toast for expected WebSocket failures\n// toast.error('Connection error. Retrying...');\n};}catch(error){console.log('Error connecting to WebSocket:',error);}};const handleMessage=data=>{switch(data.type){case'metrics_update':setMetrics(data.data);break;case'new_event':setEvents(prev=>[data.data,...prev.slice(0,99)]);// Keep last 100 events\ntoast.success(\"New event: \".concat(data.data.message));break;case'alert':toast.error(\"Alert: \".concat(data.data.message));break;case'events':setEvents(data.data);break;case'agents':setAgents(data.data);break;case'subscription_confirmed':console.log('Subscribed to channels:',data.channels);break;default:console.log('Unknown message type:',data.type);}};const sendMessage=message=>{if(wsRef.current&&wsRef.current.readyState===WebSocket.OPEN){wsRef.current.send(JSON.stringify(message));}};useEffect(()=>{// Only attempt WebSocket connection if the endpoint exists\n// For now, we'll skip WebSocket connection to prevent app loading issues\n// connect();\nreturn()=>{if(wsRef.current){wsRef.current.close();}if(reconnectTimeoutRef.current){clearTimeout(reconnectTimeoutRef.current);}};},[]);const value={isConnected,metrics,events,agents,sendMessage};return/*#__PURE__*/_jsx(WebSocketContext.Provider,{value:value,children:children});}export function useWebSocket(){const context=useContext(WebSocketContext);if(context===undefined){throw new Error('useWebSocket must be used within a WebSocketProvider');}return context;}","map":{"version":3,"names":["React","createContext","useContext","useEffect","useRef","useState","toast","jsx","_jsx","WebSocketContext","WebSocketProvider","_ref","children","isConnected","setIsConnected","metrics","setMetrics","events","setEvents","agents","setAgents","wsRef","reconnectTimeoutRef","connect","protocol","window","location","wsUrl","concat","host","current","WebSocket","onopen","console","log","send","JSON","stringify","action","channels","onmessage","event","data","parse","handleMessage","error","onclose","onerror","type","prev","slice","success","message","sendMessage","readyState","OPEN","close","clearTimeout","value","Provider","useWebSocket","context","undefined","Error"],"sources":["/Users/alex/watchtower/dashboard/frontend/src/hooks/useWebSocket.js"],"sourcesContent":["import React, { createContext, useContext, useEffect, useRef, useState } from 'react';\nimport toast from 'react-hot-toast';\n\nconst WebSocketContext = createContext();\n\nexport function WebSocketProvider({ children }) {\n  const [isConnected, setIsConnected] = useState(false);\n  const [metrics, setMetrics] = useState(null);\n  const [events, setEvents] = useState([]);\n  const [agents, setAgents] = useState([]);\n  const wsRef = useRef(null);\n  const reconnectTimeoutRef = useRef(null);\n\n  const connect = () => {\n    try {\n      const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';\n      const wsUrl = `${protocol}//${window.location.host}/dashboard/ws`;\n      \n      wsRef.current = new WebSocket(wsUrl);\n      \n      wsRef.current.onopen = () => {\n        setIsConnected(true);\n        console.log('WebSocket connected');\n        \n        // Subscribe to dashboard updates\n        wsRef.current.send(JSON.stringify({\n          action: 'subscribe',\n          channels: ['metrics', 'events', 'agents']\n        }));\n      };\n      \n      wsRef.current.onmessage = (event) => {\n        try {\n          const data = JSON.parse(event.data);\n          handleMessage(data);\n        } catch (error) {\n          console.error('Error parsing WebSocket message:', error);\n        }\n      };\n      \n      wsRef.current.onclose = () => {\n        setIsConnected(false);\n        console.log('WebSocket disconnected - this is expected if WebSocket endpoint is not available');\n        \n        // Don't attempt to reconnect if the endpoint doesn't exist\n        // reconnectTimeoutRef.current = setTimeout(() => {\n        //   connect();\n        // }, 5000);\n      };\n      \n      wsRef.current.onerror = (error) => {\n        console.log('WebSocket connection failed - this is expected if WebSocket endpoint is not available');\n        // Don't show error toast for expected WebSocket failures\n        // toast.error('Connection error. Retrying...');\n      };\n      \n    } catch (error) {\n      console.log('Error connecting to WebSocket:', error);\n    }\n  };\n\n  const handleMessage = (data) => {\n    switch (data.type) {\n      case 'metrics_update':\n        setMetrics(data.data);\n        break;\n      case 'new_event':\n        setEvents(prev => [data.data, ...prev.slice(0, 99)]); // Keep last 100 events\n        toast.success(`New event: ${data.data.message}`);\n        break;\n      case 'alert':\n        toast.error(`Alert: ${data.data.message}`);\n        break;\n      case 'events':\n        setEvents(data.data);\n        break;\n      case 'agents':\n        setAgents(data.data);\n        break;\n      case 'subscription_confirmed':\n        console.log('Subscribed to channels:', data.channels);\n        break;\n      default:\n        console.log('Unknown message type:', data.type);\n    }\n  };\n\n  const sendMessage = (message) => {\n    if (wsRef.current && wsRef.current.readyState === WebSocket.OPEN) {\n      wsRef.current.send(JSON.stringify(message));\n    }\n  };\n\n  useEffect(() => {\n    // Only attempt WebSocket connection if the endpoint exists\n    // For now, we'll skip WebSocket connection to prevent app loading issues\n    // connect();\n    \n    return () => {\n      if (wsRef.current) {\n        wsRef.current.close();\n      }\n      if (reconnectTimeoutRef.current) {\n        clearTimeout(reconnectTimeoutRef.current);\n      }\n    };\n  }, []);\n\n  const value = {\n    isConnected,\n    metrics,\n    events,\n    agents,\n    sendMessage\n  };\n\n  return (\n    <WebSocketContext.Provider value={value}>\n      {children}\n    </WebSocketContext.Provider>\n  );\n}\n\nexport function useWebSocket() {\n  const context = useContext(WebSocketContext);\n  if (context === undefined) {\n    throw new Error('useWebSocket must be used within a WebSocketProvider');\n  }\n  return context;\n} "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}